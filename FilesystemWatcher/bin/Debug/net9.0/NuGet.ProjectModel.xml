<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NuGet.ProjectModel</name>
    </assembly>
    <members>
        <member name="P:NuGet.ProjectModel.CacheFile.ExpectedPackageFilePaths">
            <summary>
            Gets or sets a list of package paths that must exist in order for the project to be considered up-to-date.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.CacheFile.HasAnyMissingPackageFiles">
            <summary>
            Gets or sets a value indicating if one or more of the expected files are missing.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.CacheFile.ProjectFilePath">
            <summary>
            Gets or sets the full path to the project file.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.CircularMemoryStream">
            <summary>
            A circular memory stream backed by a fixed-size byte buffer.
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.DependencyGraphSpec.UseLegacyHashFunction">
            <summary>
            Allows a user to enable the legacy SHA512 hash function for dgSpec files which is used by no-op.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.DependencyGraphSpec.Restore">
            <summary>
            Projects to restore.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.DependencyGraphSpec.Projects">
            <summary>
            All project specs.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.DependencyGraphSpec.WithProjectClosure(System.String)">
            <summary>
            Retrieve a DependencyGraphSpec with the project closure.
            </summary>
            <param name="projectUniqueName"></param>
            <returns></returns>
        </member>
        <member name="M:NuGet.ProjectModel.DependencyGraphSpec.CreateFromClosure(System.String,System.Collections.Generic.IReadOnlyList{NuGet.ProjectModel.PackageSpec})">
            <summary>
            Creates a new <see cref="T:NuGet.ProjectModel.DependencyGraphSpec" /> from a project name and project closure.
            </summary>
            <param name="projectUniqueName">The project's unique name.</param>
            <param name="closure">The project's closure</param>
            <returns>A <see cref="T:NuGet.ProjectModel.DependencyGraphSpec" />.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="projectUniqueName" />
            is <see langword="null" /> or an empty string.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="closure" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:NuGet.ProjectModel.DependencyGraphSpec.GetClosure(System.String)">
            <summary>
            Retrieve the full project closure including the root project itself.
            </summary>
            <remarks>Results are not sorted in any form.</remarks>
        </member>
        <member name="M:NuGet.ProjectModel.DependencyGraphSpec.SortPackagesByDependencyOrder(System.Collections.Generic.IEnumerable{NuGet.ProjectModel.PackageSpec})">
            <summary>
            Order dependencies by children first.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.DependencyGraphSpec.GetPackageSpecId(NuGet.ProjectModel.PackageSpec)">
            <summary>
            PackageSpec -> id
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.DependencyGraphSpec.GetPackageSpecDependencyIds(NuGet.ProjectModel.PackageSpec)">
            <summary>
            PackageSpec -> Project dependency ids
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.ExternalProjectReference">
            <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.ExternalProjectReference.#ctor(System.String,NuGet.ProjectModel.PackageSpec,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
            <param name="uniqueName">unique project name or full path</param>
            <param name="packageSpec">project.json package spec.</param>
            <param name="msbuildProjectPath">project file if one exists</param>
            <param name="projectReferences">unique names of the referenced projects</param>
        </member>
        <member name="M:NuGet.ProjectModel.ExternalProjectReference.#ctor(System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
            <param name="uniqueName">unique project name or full path</param>
            <param name="packageSpecPath">project.json file path or null if none exists</param>
            <param name="msbuildProjectPath">project file if one exists</param>
            <param name="projectReferences">unique names of the referenced projects</param>
        </member>
        <member name="P:NuGet.ProjectModel.ExternalProjectReference.UniqueName">
            <summary>
            Unique name of the external project
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ExternalProjectReference.PackageSpec">
            <summary>
            The path to the project.json file representing the NuGet dependencies of the project
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ExternalProjectReference.ExternalProjectReferences">
            <summary>
            A list of other external projects this project references. Uses the UniqueName.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ExternalProjectReference.MSBuildProjectPath">
            <summary>
            Path to msbuild project file. Ex: xproj, csproj
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ExternalProjectReference.ProjectJsonPath">
            <summary>
            Path to project.json
            </summary>
            <remarks>This may be null for projects that do not contain project.json.</remarks>
        </member>
        <member name="P:NuGet.ProjectModel.ExternalProjectReference.PackageSpecProjectName">
            <summary>
            Project name used for project.json
            </summary>
            <remarks>This may be null for projects that do not contain project.json.</remarks>
        </member>
        <member name="P:NuGet.ProjectModel.ExternalProjectReference.ProjectName">
            <summary>
            Project name from the package spec or msbuild file.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.FnvHash64Function">
            <summary>
            A Fowler-Noll-Vo (FNV) 64-bit hash function that supports non-cryptographic hashing to optimize speed and minimize collisions.
            https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.HashObjectWriter">
             <summary>
             Generates a hash from an object graph.
            
             This is non-private only to facilitate unit testing.
             </summary>
        </member>
        <member name="M:NuGet.ProjectModel.HashObjectWriter.#ctor(NuGet.Packaging.IHashFunction)">
            <summary>
            Creates a new instance with the provide hash function.
            </summary>
            <param name="hashFunc">An <see cref="T:NuGet.Packaging.IHashFunction"/> instance.  Throws if <see langword="null" />.</param>
        </member>
        <member name="M:NuGet.ProjectModel.HashObjectWriter.GetHash">
             <summary>
             Gets the hash for the object.
            
             Once GetHash is called, no further writing is allowed.
             </summary>
             <returns>A hash of the object.</returns>
        </member>
        <member name="T:NuGet.ProjectModel.IExternalProjectReferenceProvider">
            <summary>
            Provides external project reference closures.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.IExternalProjectReferenceProvider.GetReferences(System.String)">
            <summary>
            Get the full p2p closure from an msbuild project path.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.IExternalProjectReferenceProvider.GetEntryPoints">
            <summary>
            Returns all known entry points.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.JsonPackageSpecReader.GetPackageSpec(System.String,System.String)">
            <summary>
            Load and parse a project.json file
            </summary>
            <param name="name">project name</param>
            <param name="packageSpecPath">file path</param>
        </member>
        <member name="F:NuGet.ProjectModel.JsonUtility.DefaultLoadSettings">
            <summary>
            JsonLoadSettings with line info and comments ignored.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.JsonUtility.LoadJson(System.IO.TextReader)">
            <summary>
            Load json from a file to a JObject using the default load settings.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.LazyStringSplit">
            <summary>
                Splits a string by a delimiter, producing substrings lazily during enumeration.
                Skips empty items, behaving equivalently to <see cref="M:System.String.Split(System.Char[])"/> with
                <see cref="F:System.StringSplitOptions.RemoveEmptyEntries"/>.
            </summary>
            <remarks>
                Unlike <see cref="M:System.String.Split(System.Char[])"/> and overloads, <see cref="T:NuGet.ProjectModel.LazyStringSplit"/>
                does not allocate an array for the return, and allocates strings on demand during
                enumeration. A custom enumerator type is used so that the only allocations made are
                the substrings themselves. We also avoid the large internal arrays assigned by the
                methods on <see cref="T:System.String"/>.
            </remarks>
        </member>
        <member name="M:NuGet.ProjectModel.LazyStringSplitExtensions.FirstOrDefault(NuGet.ProjectModel.LazyStringSplit)">
            <remarks>
                This extension method has special knowledge of the <see cref="T:NuGet.ProjectModel.LazyStringSplit"/> type and
                can compute its result without allocation.
            </remarks>
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.Level">
            <summary>
            Level to indicate if this is an error or wanring.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.Code">
            <summary>
            Indicates the NuGet error code.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.Message">
            <summary>
            Indicates the staring generated by the code to go with the error code.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.ProjectPath">
            <summary>
            Indicates the project for which the error was thrown.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.WarningLevel">
            <summary>
            Level to indicate the warning level for the message.
            This is relevant only if the Level == LogLevel.Warning.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.FilePath">
            <summary>
            Indicates the file for which the error was thrown.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.StartLineNumber">
            <summary>
            Indicates the starting line for which the error was thrown.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.StartColumnNumber">
            <summary>
            Indicates the starting column for which the error was thrown.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.EndLineNumber">
            <summary>
            Indicates the ending line for which the error was thrown.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.EndColumnNumber">
            <summary>
            Indicates the ending column for which the error was thrown.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.LibraryId">
            <summary>
            Project or Package Id
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.IAssetsLogMessage.TargetGraphs">
            <summary>
            List of TargetGraphs
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.LockFileExtensions.GetTargetGraphs(NuGet.ProjectModel.IAssetsLogMessage,NuGet.ProjectModel.LockFile)">
            <summary>
            Get target graphs for the current log message.
            </summary>
            <remarks>If the message does not contain target graphs all graphs in the file
            will be returned.</remarks>
        </member>
        <member name="M:NuGet.ProjectModel.LockFileExtensions.GetTargetLibraries(NuGet.ProjectModel.IAssetsLogMessage,NuGet.ProjectModel.LockFile)">
            <summary>
            Get the library from each target graph it exists in.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.LockFileExtensions.GetTargetLibrary(NuGet.ProjectModel.LockFileTarget,System.String)">
            <summary>
            Get the library by id from the target graph.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.LockFileFormat.WriteLogMessage(Newtonsoft.Json.JsonWriter,NuGet.ProjectModel.IAssetsLogMessage,System.String)">
            <summary>
            Writes the <see cref="T:NuGet.ProjectModel.IAssetsLogMessage"/> object to the <see cref="T:Newtonsoft.Json.JsonWriter"/>.
            </summary>
            <param name="logMessage"><code>IAssetsLogMessage</code> representing the log message.</param>
        </member>
        <member name="M:NuGet.ProjectModel.LockFileFormat.ReadLogMessage(Newtonsoft.Json.Linq.JObject,System.String)">
            <summary>
            Converts an <code>JObject</code> into an <code>IAssetsLogMessage</code>.
            </summary>
            <param name="json"><code>JObject</code> containg the json representation of the log message.</param>
            <returns><code>IAssetsLogMessage</code> representing the log message.</returns>
        </member>
        <member name="P:NuGet.ProjectModel.LockFileLibrary.Path">
            <summary>
            Relative path to the project.json file for projects
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.LockFileLibrary.MSBuildProject">
            <summary>
            Relative path to the msbuild project file. Ex: xproj, csproj
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.LockFileLibrary.Clone">
            <summary>
            Makes a deep clone of the lock file library.
            </summary>
            <returns>The cloned lock file library.</returns>
        </member>
        <member name="T:NuGet.ProjectModel.Utf8JsonStreamIAssetsLogMessageConverter">
            <summary>
            A <see cref="T:NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1"/> to allow read JSON into <see cref="T:NuGet.ProjectModel.IAssetsLogMessage"/>
            </summary>
            <example>
            {
                "code": "<see cref="T:NuGet.Common.NuGetLogCode"/>",
                "level": "<see cref="T:NuGet.Common.LogLevel"/>",
                "message": "test log message",
                "warningLevel": <see cref="T:NuGet.Common.WarningLevel"/>,
                "filePath": "C:\a\file\path.txt",
                "startLineNumber": 1,
                "startColumnNumber": 2,
                "endLineNumber": 10,
                "endcolumnNumber": 20,
                "libraryId": "libraryId",
                "targetGraphs": [
                    "targetGraph1"
                ]
            }
            </example>
        </member>
        <member name="T:NuGet.ProjectModel.Utf8JsonStreamLockFileConverter">
            <summary>
            A <see cref="T:NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1"/> to allow read JSON into <see cref="T:NuGet.ProjectModel.LockFile"/>
            </summary>
            <example>
            {
                "version": 3,
                "targets": { <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileTargetConverter"/> },
                "libraries": { <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileLibraryConverter"/> },
                "projectFileDependencyGroups": { <see cref="T:NuGet.ProjectModel.Utf8JsonStreamProjectFileDependencyGroupConverter"/> },
                "packageFolders": { <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1"/> },
                "project": { <see cref="M:NuGet.ProjectModel.JsonPackageSpecReader.GetPackageSpec(NuGet.ProjectModel.Utf8JsonStreamReader@,System.String,System.String,NuGet.Common.IEnvironmentVariableReader,System.String)"/> },
                "logs": [ <see cref="T:NuGet.ProjectModel.Utf8JsonStreamIAssetsLogMessageConverter"/> ]
            }
            </example>
        </member>
        <member name="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1">
            <summary>
            A <see cref="T:NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1"/> to allow read JSON into <see cref="T:NuGet.ProjectModel.LockFileItem"/>
            </summary>
            <example>
            "path/to/the.dll": {
                "property1": "val1",
                "property2": 2
                "property3": true
                "property4": false
            }
            </example>
        </member>
        <member name="T:NuGet.ProjectModel.Utf8JsonStreamLockFileLibraryConverter">
            <summary>
            A <see cref="T:NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1"/> to allow read JSON into <see cref="T:NuGet.ProjectModel.LockFileLibrary"/>
            </summary>
            <example>
            "PackageA/1.0.0": {
                "sha512": "ASha512",
                "type": "package",
                "path": "C:\a\test\path",
                "files": [
                    "PackageA.nuspec",
                    "lib/netstandard2.0/PackageA.dll"
                ],
                "msbuildProject": "bar",
                "servicable": true,
                "hasTools": true,
            }
            </example>
        </member>
        <member name="T:NuGet.ProjectModel.Utf8JsonStreamLockFileTargetConverter">
            <summary>
            A <see cref="T:NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1"/> to allow read JSON into <see cref="T:NuGet.ProjectModel.LockFileTarget"/>
            </summary>
            <example>
            "net45/win8": {
                <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileTargetLibraryConverter"/>,
            }
            </example>
        </member>
        <member name="T:NuGet.ProjectModel.Utf8JsonStreamLockFileTargetLibraryConverter">
            <summary>
            A <see cref="T:NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1"/> to allow read JSON into <see cref="T:NuGet.ProjectModel.LockFileTargetLibrary"/>
            </summary>
            <example>
            "Lirbary/1.0.0": {
                "type": "package",
                "framework": ".NETCoreApp,Version=v6.0",
                "dependencies": {
                    "Library.Name": "1.0.1",
                    "Parser.Json": "10.0.0",
                },
                "frameworkAssemblies": [
                    "System"
                ],
                "compile": {
                    <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1"/>,
                },
                "runtime": {
                    <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1"/>,
                },
                "resource": {
                    <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1"/>,
                },
                "contentFiles": {
                    <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1"/>,
                },
                "runtimeTargets": {
                    <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1"/>,
                },
                "tools": {
                    <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1"/>,
                },
                "embed": {
                    <see cref="T:NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1"/>,
                },
                "frameworkReferences": [
                    "Framework1",
                ]
            }
            </example>
        </member>
        <member name="M:NuGet.ProjectModel.MacroStringsUtility.ApplyMacros(System.Collections.Generic.IList{System.String},System.String,System.String,System.StringComparison)">
            <summary>
            Applies macros in place to every string in the list.
            Macros are applied only at the beginning of a string.
            </summary>
            <param name="list">The list of elements to apply the macro on.</param>
            <param name="macroValue">The macro value that'll need to match from the strings.</param>
            <param name="macroName">The macro that'll replace the value within the string.</param>
            <param name="stringComparison">The comparer to use. Normally these strings are paths, so the comparer should be OS aware.</param>
        </member>
        <member name="M:NuGet.ProjectModel.MacroStringsUtility.ApplyMacro(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Applies macro to the string in the list.
            </summary>
            <param name="originalString">The string to apply the macro on.</param>
            <param name="macroValue">The macro value that'll need to match from the string.</param>
            <param name="macroName">The macro that'll replace the value within the string.</param>
            <param name="stringComparison">The comparer to use. Normally these strings are paths, so the comparer should be OS aware.</param>
        </member>
        <member name="T:NuGet.ProjectModel.NoAllocNewLineStreamWriter">
            <summary>
            Represents a <see cref="T:System.IO.StreamWriter"/> that does not allocate a new string when accessing <see cref="P:System.IO.TextWriter.NewLine" />.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.NoAllocNewLineStreamWriter.NewLine">
             <summary>
             Gets or sets the line terminator string used by the current TextWriter.
             </summary>
             <remarks>
             The base implementation of <see cref="P:System.IO.TextWriter.NewLine" />in .NET Framework allocates a new string every time it is accessed and looks like this:
             <code>
             public virtual string NewLine
             {
                 get
                 {
                     return new string (CoreNewLine);
                 }
                 set
                 {
                     if (value == null)
                     {
                         value = "\r\n";
                     }
             
                     CoreNewLine = value.ToCharArray();
                 }
             }
             </code>
            
             This implementation instead returns a cached string to be used by the caller.
             </remarks>
        </member>
        <member name="P:NuGet.ProjectModel.PackagesConfigProjectRestoreMetadata.PackagesConfigPath">
            <summary>
            Full path to the packages.config file, if it exists. Only valid when ProjectStyle is PackagesConfig.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackagesConfigProjectRestoreMetadata.RepositoryPath">
            <summary>
            User packages repository path.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.PackageSpec">
            <summary>
            Represents the specification of a package that can be built.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackageSpec.Dependencies">
            <summary>
            List of dependencies that apply to all frameworks.
            <see cref="F:NuGet.ProjectModel.ProjectStyle.PackageReference"/> based projects must not use this list and instead use the one in the <see cref="P:NuGet.ProjectModel.PackageSpec.TargetFrameworks"/> property which is a list of the <see cref="T:NuGet.ProjectModel.TargetFrameworkInformation"/> type.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackageSpec.RestoreSettings">
            <summary>
            Project Settings is used to pass settings like HideWarningsAndErrors down to lower levels.
            Currently they do not include any settings that affect the final result of restore.
            This should not be part of the Equals and GetHashCode.
            Don't write this to the package spec
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackageSpec.RestoreMetadata">
            <summary>
            Additional MSBuild properties.
            </summary>
            <remarks>Optional. This is normally set for internal use only.</remarks>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpec.Clone">
            <summary>
            Clone a PackageSpec
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecExtensions.GetTargetFramework(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Get the nearest framework available in the project.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecExtensions.GetRestoreMetadataFramework(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Get restore metadata framework. This is based on the project's target frameworks, then an 
            exact match is found under restore metadata.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecOperations.AddOrUpdateDependency(NuGet.ProjectModel.PackageSpec,NuGet.Packaging.Core.PackageDependency)">
            <summary>
            Add or Update the dependencies in the spec. If the package exists in any of the dependencies list, only those will be updated.
            If the package does not exist in any of dependencies lists,
            if the <see cref="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectStyle" /> is <see cref="F:NuGet.ProjectModel.ProjectStyle.PackageReference"/>
            then the <see cref="T:NuGet.ProjectModel.TargetFrameworkInformation"/> will be updated,
            otherwise, the generic dependencies will be updated.
            </summary>
            <param name="spec">PackageSpec to update. Cannot be <see langword="null"/></param>
            <param name="dependency">Dependency to add. Cannot be <see langword="null"/> </param>
            <exception cref="T:System.ArgumentNullException"> If <paramref name="spec"/> or <paramref name="dependency"/> is <see langword="null"/> </exception>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecOperations.AddOrUpdateDependency(NuGet.ProjectModel.PackageSpec,NuGet.Packaging.Core.PackageIdentity)">
            <summary>
            Add or Update the dependencies in the spec. If the package exists in any of the dependencies list, only those will be updated.
            If the package does not exist in any of dependencies lists,
            if the <see cref="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectStyle" /> is <see cref="F:NuGet.ProjectModel.ProjectStyle.PackageReference"/>
            then the <see cref="T:NuGet.ProjectModel.TargetFrameworkInformation"/> will be updated,
            otherwise, the generic dependencies will be updated.
            </summary>
            <param name="spec">PackageSpec to update. Cannot be <see langword="null"/></param>
            <param name="identity">Dependency to add. Cannot be <see langword="null"/> </param>
            <exception cref="T:System.ArgumentNullException"> If <paramref name="spec"/> or <paramref name="identity"/> is <see langword="null"/> </exception>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecOperations.AddOrUpdateDependency(NuGet.ProjectModel.PackageSpec,NuGet.Packaging.Core.PackageDependency,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
            <summary>
            Add or Update the dependencies in the spec. Only the frameworks specified will be considered. 
            </summary>
            <param name="spec">PackageSpec to update. Cannot be <see langword="null"/></param>
            <param name="dependency">Dependency to add. Cannot be <see langword="null"/> </param>
            <param name="frameworksToAdd">The frameworks to be considered. If <see langword="null"/>, then all frameworks will be considered. </param>
            <exception cref="T:System.ArgumentNullException"> If <paramref name="spec"/> or <paramref name="dependency"/> is <see langword="null"/> </exception>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecOperations.AddOrUpdateDependency(NuGet.ProjectModel.PackageSpec,NuGet.Packaging.Core.PackageIdentity,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
            <summary>
            Add or Update the dependencies in the spec. Only the frameworks specified will be considered. 
            </summary>
            <param name="spec">PackageSpec to update. Cannot be <see langword="null"/></param>
            <param name="identity">Dependency to add. Cannot be <see langword="null"/> </param>
            <param name="frameworksToAdd">The frameworks to be considered. If <see langword="null"/>, then all frameworks will be considered. </param>
            <exception cref="T:System.ArgumentNullException"> If <paramref name="spec"/> or <paramref name="identity"/> is <see langword="null"/> </exception>
        </member>
        <member name="T:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider">
            <summary>
            Handles both external references and projects discovered through directories
            If the type is set to external project directory discovery will be disabled.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider.GetDependenciesFromExternalReference(NuGet.ProjectModel.ExternalProjectReference,NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
            <summary>
            UWP Project.json
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecUtility.SpecifySnapshot(System.String,System.String)">
            <summary>
            Apply a snapshot value.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecUtility.IsSnapshotVersion(System.String)">
            <summary>
            True if the string is a snapshot version.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.PackageSpecWriter">
             <summary>
             Writes out a PackageSpec object graph.
            
             This is non-private only to facilitate unit testing.
             </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecWriter.Write(NuGet.ProjectModel.PackageSpec,NuGet.RuntimeModel.IObjectWriter)">
            <summary>
            Writes a PackageSpec to an <c>NuGet.Common.IObjectWriter</c> instance.
            </summary>
            <param name="packageSpec">A <c>PackageSpec</c> instance.</param>
            <param name="writer">An <c>NuGet.Common.IObjectWriter</c> instance.</param>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecWriter.WriteToFile(NuGet.ProjectModel.PackageSpec,System.String)">
            <summary>
            Writes a PackageSpec to a file.
            </summary>
            <param name="packageSpec">A <c>PackageSpec</c> instance.</param>
            <param name="filePath">A file path to write to.</param>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecWriter.SetMSBuildMetadata(NuGet.RuntimeModel.IObjectWriter,NuGet.ProjectModel.PackageSpec,NuGet.Common.IEnvironmentVariableReader)">
            <summary>
            This method sets the msbuild metadata that's important for restore. Ensures that frameworks regardless of which way they're stores in the metadata(full name or short tfm name) are written out the same.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecWriter.SetDependencies(NuGet.RuntimeModel.IObjectWriter,System.String,System.Collections.Generic.IEnumerable{NuGet.LibraryModel.LibraryDependency})">
            <summary>
            This method sorts the libraries based on the name
            This method also writes out the normalized versions to avoid cases where original string is set because it was gotten through project system vs being installed from PM UI
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackageSpecWriter.SetCentralTransitveDependencyGroup(NuGet.RuntimeModel.IObjectWriter,System.String,System.Collections.Generic.IEnumerable{NuGet.LibraryModel.LibraryDependency})">
            <summary>
            The central transitive dependecy groups are used for pack operation.
            The metadata needed for pack is composed from:
                Name, IncludeType, SuppressParent and Version
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.PackageDependencyType.Direct">
            <summary>
            Package is directly installed into the project.
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.PackageDependencyType.Transitive">
            <summary>
            Package is transitively available to the project instead of directly installed.
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.PackageDependencyType.Project">
            <summary>
            
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.PackageDependencyType.CentralTransitive">
            <summary>
            Package is transitively available to the project instead of directly installed but is also enforced by the central package version file.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.PackagesLockFileTarget">
            <summary>
            FrameworkName/RuntimeIdentifier combination
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackagesLockFileTarget.TargetFramework">
            <summary>
            Target framework.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackagesLockFileTarget.RuntimeIdentifier">
            <summary>	
            Null for RIDless graphs.	
            </summary>	
        </member>
        <member name="P:NuGet.ProjectModel.PackagesLockFileTarget.Dependencies">
            <summary>
            
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackagesLockFileTarget.Name">
            <summary>
            Full framework name.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.PackagesLockFileUtilities.IsLockFileValid(NuGet.ProjectModel.DependencyGraphSpec,NuGet.ProjectModel.PackagesLockFile)">
            <summary>
            The lock file will get invalidated if one or more of the below are true
                1. The target frameworks list of the current project was updated.
                2. The runtime list of the current project waw updated.
                3. The packages of the current project were updated.
                4. The packages of the dependent projects were updated.
                5. The framework list of the dependent projects were updated with frameworks incompatible with the main project framework.
                6. If the version of the <paramref name="nuGetLockFile"/> is larger than the current tools <see cref="F:NuGet.ProjectModel.PackagesLockFileFormat.PackagesLockFileVersion"/>.
            </summary>
            <param name="dgSpec">The <see cref="T:NuGet.ProjectModel.DependencyGraphSpec"/> for the new project defintion.</param>
            <param name="nuGetLockFile">The current <see cref="T:NuGet.ProjectModel.PackagesLockFile"/>.</param>
            <returns>Returns LockFileValidityWithInvalidReasons object with IsValid set to true if the lock file is valid false otherwise.
            The second return type is a localized message that indicates in further detail the reason for the inconsistency.</returns>
        </member>
        <member name="M:NuGet.ProjectModel.PackagesLockFileUtilities.IsLockFileStillValid(NuGet.ProjectModel.PackagesLockFile,NuGet.ProjectModel.PackagesLockFile)">
            <summary>Compares two lock files to check if the structure is the same (all values are the same, other
            than SHA hash), and matches dependencies so the caller can easily compare SHA hashes.</summary>
            <param name="expected">The expected lock file structure. Usuaully generated from the project.</param>
            <param name="actual">The lock file that was loaded from the file on disk.</param>
            <returns>A <see cref="T:NuGet.ProjectModel.PackagesLockFileUtilities.LockFileValidityWithMatchedResults"/>.</returns>
        </member>
        <member name="M:NuGet.ProjectModel.PackagesLockFileUtilities.HasProjectTransitiveDependencyChanged(System.Collections.Generic.IReadOnlyDictionary{System.String,NuGet.LibraryModel.CentralPackageVersion},System.Collections.Generic.IList{NuGet.ProjectModel.LockFileDependency},System.Collections.Generic.IList{NuGet.ProjectModel.LockFileDependency})">
            <summary>
            The method will return true if:
            1. If a transitive dependency from the lock file is now added to the central file.
                or
            1. If there is a mistmatch between the RequestedVersion of a lock file dependency marked as CentralTransitive and the the version specified in the central package management file.
                or
            2. If a central version that is a transitive dependency is removed from CPVM the lock file is invalidated.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.PackagesLockFileUtilities.LockFileValidityWithMatchedResults">
            <summary>
            A class to return information about lock file validity
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackagesLockFileUtilities.LockFileValidityWithMatchedResults.IsValid">
            <summary>
            True if the lock file had the expected structure (all values expected, other than content hash)
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.PackagesLockFileUtilities.LockFileValidityWithMatchedResults.MatchedDependencies">
            <summary>
            A list of matched dependencies, so content sha can easily be checked.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.LockFileValidationResult">
            <summary>
            A class to return information about lock file validity with invalid reasons.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.LockFileValidationResult.IsValid">
            <summary>
            True if the packages.lock.json file dependencies match project.assets.json file dependencies
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.LockFileValidationResult.InvalidReasons">
            <summary>
            A list of reasons why lock file is invalid
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectStyle">
            <summary>
            Restore behavior type.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectPath">
            <summary>
            MSBuild project file path.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectJsonPath">
            <summary>
            Full path to the project.json file if it exists.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.OutputPath">
            <summary>
            Assets file output path.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectName">
            <summary>
            Friendly project name.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectUniqueName">
            <summary>
            Name unique to the project across the solution.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.Sources">
            <summary>
            Package feed sources.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.PackagesPath">
            <summary>
            User packages folder path.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.CacheFilePath">
            <summary>
            Cache file path
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.FallbackFolders">
            <summary>
            Fallback folders.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ConfigFilePaths">
            <summary>
            ConfigFilePaths used.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.TargetFrameworks">
            <summary>
            Framework specific metadata, this may be a subset of the project's frameworks.
            Operations to determine the nearest framework should be done against the project's frameworks,
            and then matched directly to this section.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.OriginalTargetFrameworks">
            <summary>
            Original target frameworks strings. These are used to match msbuild conditionals to $(TargetFramework)
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.CrossTargeting">
            <summary>
            True if $(TargetFrameworks) is used and the build is using Cross Targeting.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.LegacyPackagesDirectory">
            <summary>
            Whether or not to restore the packages directory using the legacy format, which write original case paths
            instead of lowercase.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.Files">
            <summary>
            Asset files. These should be equivalent to the files that would be
            in the nupkg after packing the project.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ValidateRuntimeAssets">
            <summary>
            Compatibility check for runtime framework assets.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.SkipContentFileWrite">
            <summary>
            True if this is a Legacy Package Reference project
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectWideWarningProperties">
            <summary>
            Contains Project wide properties for Warnings.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.CentralPackageVersionsEnabled">
            <summary>
            Gets or sets a value indicating whether or not central package management is enabled.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.CentralPackageVersionOverrideDisabled">
            <summary>
            Gets or sets a value indicating whether or not a package version specified centrally can be overridden.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.CentralPackageFloatingVersionsEnabled">
            <summary>
            Gets or sets a value indicating whether or not floating versions are allowed when using central package management (CPM).
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.SdkAnalysisLevel">
            <summary>
            A unified flag to help users manage their SDK warning levels. Example: 9.0.100.
            When introducing a new warning or error use this property to
            allow users to tell the sdk "treat me as if I were SDK x.y.z" and manage breaking changes
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.UsingMicrosoftNETSdk">
            <summary>
            Indicates that Microsoft.NET.Sdk is being used.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFile.PackagePath">
            <summary>
            Relative path that would be used within a package.
            This will be used to determine the asset type.
            Example: lib/net45/a.dll
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFile.AbsolutePath">
            <summary>
            Absolute path on disk.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo.FrameworkName">
            <summary>
            Target framework
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo.ProjectReferences">
            <summary>
            Project references
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreReference.ProjectUniqueName">
            <summary>
            Project unique name.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreReference.ProjectPath">
            <summary>
            Full path to the msbuild project file.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.ProjectRestoreSettings">
            <summary>
            This class is used to hold restore related, project specific settings.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreSettings.HideWarningsAndErrors">
            <summary>
            Bool property is used inr estore command to not log errors and warning.
            Currently this is only being used for net core based projects on nomination.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.ProjectRestoreSettings.SdkVersion">
            <summary>
            Indicates the .NET SDK Version if any.
            In combination with SdkAnalysisLevel, it allows us to determine whether the analysis level is the default one or manually specified.
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.ProjectStyle.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.ProjectStyle.ProjectJson">
            <summary>
            UAP style, project.lock.json is generated next to project.json
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.ProjectStyle.PackageReference">
            <summary>
            MSBuild style, project.assets.json is generated in the RestoreOutputPath folder
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.ProjectStyle.DotnetCliTool">
            <summary>
            DotnetCliToolReference "project"
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.ProjectStyle.Standalone">
            <summary>
            Non-MSBuild project with no project dependencies.
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.ProjectStyle.PackagesConfig">
            <summary>
            Packages.config project
            </summary>
        </member>
        <member name="F:NuGet.ProjectModel.ProjectStyle.DotnetToolReference">
            <summary>
            DotnetToolReference project
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.RestoreAuditProperties.EnableAudit">
            <summary>
            Gets or sets a value indicating whether NuGet audit (check packages for known vulnerabilities) is enabled.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.RestoreAuditProperties.AuditLevel">
            <summary>
            Gets or sets a value indicating the NuGet audit level threshold with which vulnerabilities are reported.
            </summary>
            <value>low, moderate, high, critical</value>
        </member>
        <member name="P:NuGet.ProjectModel.RestoreAuditProperties.AuditMode">
            <summary>
            Gets or sets a value indicating which audit mode to use.
            </summary>
            <value>direct, all</value>
        </member>
        <member name="P:NuGet.ProjectModel.RestoreAuditProperties.SuppressedAdvisories">
            <summary>
            Gets or sets values indicating which advisories to suppress.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.RestoreLockProperties.RestorePackagesWithLockFile">
            <summary>
            Set when customer wants to opt into packages lock file
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.RestoreLockProperties.NuGetLockFilePath">
            <summary>
            Packages.lock.json file path including file name if customer wants to override defualt file name.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.RestoreLockProperties.RestoreLockedMode">
            <summary>
            True, if updating lock file on restore is denied.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.ArgumentNullOrEmpty">
            <summary>
              Looks up a localized string similar to Argument cannot be null or empty..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.Invalid_AttributeValue">
            <summary>
              Looks up a localized string similar to The {0} value: `{1}` is invalid. Valid example: `{2}`.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.InvalidDependencyTarget">
            <summary>
              Looks up a localized string similar to Invalid dependency target value &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.InvalidPackageType">
            <summary>
              Looks up a localized string similar to The pack options package type must be a string or array of strings in &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingLockFile">
            <summary>
              Looks up a localized string similar to Error loading lock file &apos;{0}&apos; : {1}.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingProjectJson">
            <summary>
              Looks up a localized string similar to Error reading &apos;{0}&apos; : {1}.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingProjectJsonWithLocation">
            <summary>
              Looks up a localized string similar to Error reading &apos;{0}&apos; at line {1} column {2} : {3}.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.Log_InvalidImportFramework">
            <summary>
              Looks up a localized string similar to Imports contains an invalid framework: &apos;{0}&apos; in &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.Log_ProblemReadingCacheFile">
            <summary>
              Looks up a localized string similar to Problem reading the cache file {0} : {1}.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.MissingVersionOnDependency">
            <summary>
              Looks up a localized string similar to Package dependencies must specify a version range..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.MissingVersionOnTool">
            <summary>
              Looks up a localized string similar to Tools must specify a version range..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.None">
            <summary>
              Looks up a localized string similar to None.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_CentralPackageVersionRemoved">
            <summary>
              Looks up a localized string similar to Central package management file(s) doesn&apos;t contain version range for {0} package which is specified as CentralTransitive dependency in the lock file..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_IncompatibleLockFileVersion">
            <summary>
              Looks up a localized string similar to Version specified in the packages.lock.json file is incompatible. Current tooling supports version {0} and previous formats..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_MismatchedTargetFrameworks">
            <summary>
              Looks up a localized string similar to The project target frameworks are different than the lock file&apos;s target frameworks. Lock file target frameworks: {0}. Project target frameworks {1}..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_NewTargetFramework">
            <summary>
              Looks up a localized string similar to The project target framework {0} was not found in the lock file..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_PackageReferenceAdded">
            <summary>
              Looks up a localized string similar to A new package reference was found {0} for the project target framework {1}..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_PackageReferencesHaveChanged">
            <summary>
              Looks up a localized string similar to The package references have changed for {0}. Lock file&apos;s package references: {1}, project&apos;s package references: {2}..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_PackageReferenceVersionChanged">
            <summary>
              Looks up a localized string similar to The package reference {0} version has changed from {1} to {2}..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_ProjectReferenceAdded">
            <summary>
              Looks up a localized string similar to A new project reference to {0} was found for {1} target framework..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_ProjectReferenceDependenciesHasChanged">
            <summary>
              Looks up a localized string similar to The project references {0} whose dependencies has changed..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_ProjectReferenceHasNoCompatibleTargetFramework">
            <summary>
              Looks up a localized string similar to The project {0} has no compatible target framework. .
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_ProjectReferencesHasChange">
            <summary>
              Looks up a localized string similar to The project reference {0} has changed. Current dependencies: {1} lock file&apos;s dependencies: {2}..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_ProjectTransitiveDependencyChanged">
            <summary>
              Looks up a localized string similar to Transitive dependency {0} moved to be centraly managed invalidated the lock file..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_ProjectTransitiveDependencyVersionChanged">
            <summary>
              Looks up a localized string similar to Mistmatch between the requestedVersion of a lock file dependency marked as CentralTransitive and the the version specified in the central package management file. Lock file version {0}, central package management version {1}..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_RestoreMetadataMissingTfms">
            <summary>
              Looks up a localized string similar to Restore metadata is mising the required target frameworks list. Please file a bug with repro steps on NuGet/Home if seen..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_RuntimeIdentifiersChanged">
            <summary>
              Looks up a localized string similar to The project&apos;s runtime identifiers have changed from. Project&apos;s runtime identifiers: {0}, lock file&apos;s runtime identifiers {1}..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.Strings.PackagesLockFile_UnableToLoadPackagespec">
            <summary>
              Looks up a localized string similar to Unable to load package spec for {0} project..
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.Imports">
            <summary>
            A fallback PCL framework to use when no compatible items
            were found for <see cref="P:NuGet.ProjectModel.TargetFrameworkInformation.FrameworkName"/>.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.AssetTargetFallback">
            <summary>
            If True AssetTargetFallback behavior will be used for Imports.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.Warn">
            <summary>
            Display warnings when the Imports framework is used.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.DownloadDependencies">
            <summary>
            List of dependencies that are not part of the graph resolution.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.CentralPackageVersions">
            <summary>
            Package versions defined in the Central package versions management file. 
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.FrameworkReferences">
            <summary>
            A set of unique FrameworkReferences
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.PackagesToPrune">
            <summary>
            A dictionary of packages to be pruned from the graph.
            An item existing in this dictionary means the pruning capability is enabled.
            If pruning is not enabled, this property return Empty regardless of what was specified in the items.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.RuntimeIdentifierGraphPath">
            <summary>
            The project provided runtime.json
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.ToolPathResolver.GetLockFilePath(System.String)">
            <summary>
            Given a toolDirectory path, it returns the full assets file path
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.ToolPathResolver.GetLockFilePath(System.String,NuGet.Versioning.NuGetVersion,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Given a package id, version and framework, returns the full assets file path
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.ToolPathResolver.GetToolDirectoryPath(System.String,NuGet.Versioning.NuGetVersion,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Given a package id, version and framework, returns the tool directory path where the assets/cache file are located for tools
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.ToolPathResolver.GetPackagesToolsBasePath">
            <summary>
            The base path for all restored tools
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.ToolPathResolver.GetBestToolDirectoryPath(System.String,NuGet.Versioning.VersionRange,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Returns the directory (packagesFolder/.tools/id/version for example) for the best matching version if any. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NuGet.ProjectModel.ToolPathResolver.GetAvailableToolVersions(System.String)">
            <summary>
            Given a package id, looks in the base tools folder and returns all the version available on disk, possibly none
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.Utf8JsonStreamProjectFileDependencyGroupConverter">
            <summary>
            A <see cref="T:NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1"/> to allow reading JSON into <see cref="T:NuGet.ProjectModel.ProjectFileDependencyGroup"/>
            </summary>
            <example>
            "net45": [
                "Json.Parser (>= 1.0.1)",
            ]
            </example>
        </member>
        <member name="T:NuGet.ProjectModel.Utf8JsonStreamReader">
            <summary>
            This struct is used to read over a memeory stream in parts, in order to avoid reading the entire stream into memory.
            It functions as a wrapper around <see cref="T:NuGet.ProjectModel.Utf8JsonStreamReader"/>, while maintaining a stream and a buffer to read from.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.Utf8JsonStreamReader.ReadStreamIntoBuffer(System.Text.Json.JsonReaderState)">
            <summary>
            Loops through the stream and reads it into the buffer until the buffer is full or the stream is empty, creates the Utf8JsonReader.
            </summary>
        </member>
        <member name="T:NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1">
            <summary>
            An abstract class that defines a function for reading a <see cref="T:NuGet.ProjectModel.Utf8JsonStreamReader"/> into a <typeparamref name="T"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NuGet.ProjectModel.WarningProperties">
            <summary>
            Class to hold warning properties given by project system.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.WarningProperties.WarningsAsErrors">
            <summary>
            List of Warning Codes that should be treated as Errors.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.WarningProperties.NoWarn">
            <summary>
            List of Warning Codes that should be ignored.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.WarningProperties.AllWarningsAsErrors">
            <summary>
            Indicates if all warnings should be ignored.
            </summary>
        </member>
        <member name="P:NuGet.ProjectModel.WarningProperties.WarningsNotAsErrors">
            <summary>
            List of Warning Codes that should not be treated as Errors.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.WarningProperties.GetWarningProperties(System.String,System.String,System.String,System.String)">
            <summary>
            Create warning properties from the msbuild property strings.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.WarningProperties.GetWarningProperties(System.String,System.String,System.String)">
            <summary>
            Create warning properties from the msbuild property strings.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.WarningProperties.GetWarningProperties(System.String,System.Collections.Immutable.ImmutableArray{NuGet.Common.NuGetLogCode},System.Collections.Immutable.ImmutableArray{NuGet.Common.NuGetLogCode},System.Collections.Immutable.ImmutableArray{NuGet.Common.NuGetLogCode})">
            <summary>
            Create warning properties from NuGetLogCode collection.
            </summary>
        </member>
        <member name="M:NuGet.ProjectModel.WarningProperties.GetWarningProperties(System.String,System.Collections.Immutable.ImmutableArray{NuGet.Common.NuGetLogCode},System.Collections.Immutable.ImmutableArray{NuGet.Common.NuGetLogCode})">
            <summary>
            Create warning properties from NuGetLogCode collection.
            </summary>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two enumerables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
            <typeparam name="TSource">The type of the list</typeparam>
            <typeparam name="TKey">The type of the sorting key</typeparam>
            <param name="self">This list</param>
            <param name="other">The other list</param>
            <param name="keySelector">The function to extract the key from each item in the list</param>
            <param name="orderComparer">An optional comparer for comparing keys</param>
            <param name="sequenceComparer">An optional comparer for sequences</param>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.OrderedEquals``2(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two collections for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
            <typeparam name="TSource">The type of the list</typeparam>
            <typeparam name="TKey">The type of the sorting key</typeparam>
            <param name="self">This list</param>
            <param name="other">The other list</param>
            <param name="keySelector">The function to extract the key from each item in the list</param>
            <param name="orderComparer">An optional comparer for comparing keys</param>
            <param name="sequenceComparer">An optional comparer for sequences</param>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two lists for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
            <typeparam name="TSource">The type of the list</typeparam>
            <typeparam name="TKey">The type of the sorting key</typeparam>
            <param name="self">This list</param>
            <param name="other">The other list</param>
            <param name="keySelector">The function to extract the key from each item in the list</param>
            <param name="orderComparer">An optional comparer for comparing keys</param>
            <param name="sequenceComparer">An optional comparer for sequences</param>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two collections for equality, allowing either collection to be null. If one is null, both have to be
            null for equality.
            </summary>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two lists for equality, allowing either list to be null. If one is null, both have to be
            null for equality.
            </summary>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.EqualsFalse(System.String)">
            <summary>
            Determines if the current string contains a value equal "false".  Leading and trailing whitespace are trimmed and the comparison is case-insensitive
            </summary>
            <param name="value">The string to compare.</param>
            <returns><see langword="true" /> if the current string is equal to a value of "false", otherwise <see langword="false" />.</returns>
        </member>
        <member name="T:NuGet.Shared.HashCodeCombiner">
            <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
        </member>
        <member name="M:NuGet.Shared.HashCodeCombiner.GetHashCode``2(``0,``1)">
            <summary>
            Create a unique hash code for the given set of items
            </summary>
        </member>
        <member name="M:NuGet.Shared.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
            <summary>
            Create a unique hash code for the given set of items
            </summary>
        </member>
        <member name="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IList{``0})">
             <summary>
             Avoids allocating an enumerator when enumerating an <see cref="T:System.Collections.Generic.IList`1"/>.
             </summary>
             <remarks>
             <para>
             Returns a struct-based enumerator that avoids heap allocation during enumeration.
             If the underlying type is <see cref="T:System.Collections.Generic.List`1"/> then this method will delegate to <see cref="T:System.Collections.Generic.List`1.Enumerator"/>,
             otherwise the collection's items are accessed by index via <see cref="T:System.Collections.Generic.IList`1"/>'s indexer directly.
             </para>
             <para>
             When using a struct-based enumerator, no heap allocation occurs during enumeration via <see langword="foreach" />.
             This is in contrast to the interface-based enumerator <see cref="T:System.Collections.Generic.IEnumerator`1"/> which will
             always be allocated on the heap.
             </para>
             </remarks>
             <example>
             <code>
             <![CDATA[IList<string> list = ...;
            
             foreach (string item in list.NoAllocEnumerate())
             {
                 // ...
             }]]>
             </code>
             </example>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingListEnumerable`1">
            <summary>
            Provides a struct-based enumerator for use with <see cref="T:System.Collections.Generic.IList`1"/>.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IList{``0})"/> instead.
            </summary>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingListEnumerable`1.Enumerator">
            <summary>
            A struct-based enumerator for use with <see cref="T:System.Collections.Generic.IList`1"/>.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IList{``0})"/> instead.
            </summary>
        </member>
        <member name="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IEnumerable{``0})">
             <summary>
             Avoids allocating an enumerator when enumerating an <see cref="T:System.Collections.Generic.IEnumerable`1"/> where the concrete type
             has a well known struct enumerator, such as for <see cref="T:System.Collections.Generic.List`1"/>, or when index-based access is possible via
             <see cref="T:System.Collections.Generic.IList`1"/>.
             </summary>
             <remarks>
             <para>
             Several collection types (e.g. <see cref="T:System.Collections.Generic.List`1"/>) provide a struct-based enumerator type
             (e.g. <see cref="T:System.Collections.Generic.List`1.Enumerator"/>) which the compiler can use in <see langword="foreach" /> statements.
             When using a struct-based enumerator, no heap allocation occurs during such enumeration.
             This is in contrast to the interface-based enumerator <see cref="T:System.Collections.Generic.IEnumerator`1"/> which will
             always be allocated on the heap.
             </para>
             <para>
             This method returns a custom struct enumerator that will avoid any heap allocation if <paramref name="source"/>
             (which is declared via interface <see cref="T:System.Collections.Generic.IEnumerable`1"/>) is actually of known concrete type that
             provides its own struct enumerator. If so, it delegates to that type's enumerator without any boxing
             or other heap allocation.
             </para>
             <para>
             If <paramref name="source"/> is not of a known concrete type, the returned enumerator falls back to the
             interface-based enumerator, which will be allocated on the heap. Benchmarking shows the overhead in
             such cases is low enough to be within the measurement error, meaning this is an inexpensive optimization
             that won't regress behavior and with low downside for cases where it cannot apply an optimization.
             </para>
             </remarks>
             <example>
             <code>
             <![CDATA[IEnumerable<string> source = ...;
            
             foreach (string item in source.NoAllocEnumerate())
             {
                 // ...
             }]]>
             </code>
             </example>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingEnumerable`1">
            <summary>
            Provides a struct-based enumerator for use with <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IEnumerable{``0})"/> instead.
            </summary>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingEnumerable`1.Enumerator">
            <summary>
            A struct-based enumerator for use with <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IEnumerable{``0})"/> instead.
            </summary>
        </member>
        <member name="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``2(System.Collections.Generic.IDictionary{``0,``1})">
             <summary>
             Avoids allocating an enumerator when enumerating an <see cref="T:System.Collections.Generic.IDictionary`2"/> where the concrete type
             has a well known struct enumerator, such as for <see cref="T:System.Collections.Generic.Dictionary`2"/>.
             </summary>
             <remarks>
             <para>
             Several collection types (e.g. <see cref="T:System.Collections.Generic.Dictionary`2"/>) provide a struct-based enumerator type
             (e.g. <see cref="T:System.Collections.Generic.Dictionary`2.Enumerator"/>) which the compiler can use in <see langword="foreach" /> statements.
             When using a struct-based enumerator, no heap allocation occurs during such enumeration.
             This is in contrast to the interface-based enumerator <see cref="T:System.Collections.Generic.IEnumerator`1"/> which will
             always be allocated on the heap.
             </para>
             <para>
             This method returns a custom struct enumerator that will avoid any heap allocation if <paramref name="dictionary"/>
             (which is declared via interface <see cref="T:System.Collections.Generic.IEnumerable`1"/>) is actually of known concrete type that
             provides its own struct enumerator. If so, it delegates to that type's enumerator without any boxing
             or other heap allocation.
             </para>
             <para>
             If <paramref name="dictionary"/> is not of a known concrete type, the returned enumerator falls back to the
             interface-based enumerator, which will be allocated on the heap. Benchmarking shows the overhead in
             such cases is low enough to be within the measurement error, meaning this is an inexpensive optimization
             that won't regress behavior and with low downside for cases where it cannot apply an optimization.
             </para>
             </remarks>
             <example>
             <code>
             <![CDATA[IDictionary<string, string> dictionary = ...;
            
             foreach ((string key, string value) in dictionary.NoAllocEnumerate())
             {
                 // ...
             }]]>
             </code>
             </example>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingDictionaryEnumerable`2">
            <summary>
            Provides a struct-based enumerator for use with <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``2(System.Collections.Generic.IDictionary{``0,``1})"/> instead.
            </summary>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingDictionaryEnumerable`2.Enumerator">
            <summary>
            A struct-based enumerator for use with <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``2(System.Collections.Generic.IDictionary{``0,``1})"/> instead.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
    </members>
</doc>
